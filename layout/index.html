<!DOCTYPE html>
<!-- 

  This whole thing is a massive hack. Sorry. In a rush.

-->
<html>
  <head>
    <title>CodeCards card layout</title>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script type="text/javascript" src="../public/javascripts/app.js"></script>
    <script>
function base64_encode (data) {
  function utf8_encode (argString) {
    // Encodes an ISO-8859-1 string to UTF-8  
    // 
    // version: 1109.2015
    // discuss at: http://phpjs.org/functions/utf8_encode
    // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   improved by: sowberry
    // +    tweaked by: Jack
    // +   bugfixed by: Onno Marsman
    // +   improved by: Yves Sucaet
    // +   bugfixed by: Onno Marsman
    // +   bugfixed by: Ulrich
    // +   bugfixed by: Rafal Kukawski
    // *     example 1: utf8_encode('Kevin van Zonneveld');
    // *     returns 1: 'Kevin van Zonneveld'
    if (argString === null || typeof argString === "undefined") {
        return "";
    }
 
    var string = (argString + ''); // .replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    var utftext = "",
        start, end, stringl = 0;
 
    start = end = 0;
    stringl = string.length;
    for (var n = 0; n < stringl; n++) {
        var c1 = string.charCodeAt(n);
        var enc = null;
 
        if (c1 < 128) {
            end++;
        } else if (c1 > 127 && c1 < 2048) {
            enc = String.fromCharCode((c1 >> 6) | 192) + String.fromCharCode((c1 & 63) | 128);
        } else {
            enc = String.fromCharCode((c1 >> 12) | 224) + String.fromCharCode(((c1 >> 6) & 63) | 128) + String.fromCharCode((c1 & 63) | 128);
        }
        if (enc !== null) {
            if (end > start) {
                utftext += string.slice(start, end);
            }
            utftext += enc;
            start = end = n + 1;
        }
    }
 
    if (end > start) {
        utftext += string.slice(start, stringl);
    }
 
    return utftext;
    }
    // Encodes string using MIME base64 algorithm  
    // 
    // version: 1109.2015
    // discuss at: http://phpjs.org/functions/base64_encode
    // +   original by: Tyler Akins (http://rumkin.com)
    // +   improved by: Bayron Guevara
    // +   improved by: Thunder.m
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   bugfixed by: Pellentesque Malesuada
    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // +   improved by: Rafa≈Ç Kukawski (http://kukawski.pl)
    // -    depends on: utf8_encode
    // *     example 1: base64_encode('Kevin van Zonneveld');
    // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
    // mozilla has this native
    // - but breaks in 2.0.0.12!
    //if (typeof this.window['atob'] == 'function') {
    //    return atob(data);
    //}
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
        ac = 0,
        enc = "",
        tmp_arr = [];
 
    if (!data) {
        return data;
    }
 
    data = utf8_encode(data + '');
 
    do { // pack three octets into four hexets
        o1 = data.charCodeAt(i++);
        o2 = data.charCodeAt(i++);
        o3 = data.charCodeAt(i++);
 
        bits = o1 << 16 | o2 << 8 | o3;
 
        h1 = bits >> 18 & 0x3f;
        h2 = bits >> 12 & 0x3f;
        h3 = bits >> 6 & 0x3f;
        h4 = bits & 0x3f;
 
        // use hexets to index into b64, and append result to encoded string
        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
    } while (i < data.length);
 
    enc = tmp_arr.join('');
    
    var r = data.length % 3;
    
    return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
}

      $(function() {
        var $doc = $(document),
            $tmp = $('<div></div>'),
            Language = require('interpreter/language'),
            cards = [],
            words = {};

        // SVG download links
        $doc.on('hover', '.svg', function() {
          $el = $(this);
          $svg = $el.find('svg');

          var wtmp = $svg.attr('width'),
              htmp = $svg.attr('height');

          $svg.attr({
            width: $('#size_w').val() + 'mm',
            height: $('#size_h').val() + 'mm'
          });

          if ($svg.length === 1) {
            var data = $el.html(),
                uri = "data:image/svg+xml;base64,";

            data = data.replace(/<glyph unicode="(.*)" d="/g, function(match, entity) {
              return '<glyph unicode="' + $tmp.text(entity).html() + '" d="';
            });

            data = data.replace('&nbsp;', ' ');

            data = base64_encode(data);

            $el.attr('href', uri + data);

            $svg.attr({
              width: wtmp,
              height: htmp
            });
          }
        });

        $('.options input').on('change keyup', change);

        $('select').on('change click', function() {
          var wxh = $(this).val().split(' ');
          $('#size_w').val(wxh[0]);
          $('#size_h').val(wxh[1]);
          change();
        });

        $('#toggleWords').on('click', function() {
          $('#words').toggleClass('hidden');
        });

        $('#lang').on('change keyup', function() {
          var exists = true,
              lang

          // Check language exists
          try {
            require('data/languages/' + $('#lang').val() + '.lang');
          } catch (e) {
            exists = false;
          }

          if (exists) {
            tmp = {};
            tmp[$('#lang').val()] = '*';
            lang = new Language(tmp);
            words = lang.words;
            $('#notice').text(Object.keys(words).length + ' words');
            listWords(lang.words);
          } else {
            $('#notice').text('Not found');
            listWords(false);
          }

          change();
        }).trigger('change');

        change();

        function change() {
          var mm2i = 0.0393700787,
              $svgs = $('svg'),
              widthmm = $('#size_w').val(),
              heightmm = $('#size_h').val(),
              dpi = $('#dpi').val(),
              widthpx = Math.round(widthmm * mm2i * dpi),
              heightpx = Math.round(heightmm * mm2i * dpi),
              sf = ($(document.body).innerWidth() - 40) / widthpx,
              mm2px = mm2i * dpi,
              scroll = $(window).scrollTop();

          $svgs.attr({
            width: (widthpx * sf) / 2 - 40 + 'px',
            height: (heightpx * sf) / 2 - (40 * heightpx/widthpx) + 'px'
          });

          $svgs.each(function(i, el) {
            el.setAttribute('viewBox', '0 0 ' + widthpx + ' ' + heightpx);
          });

          draw(widthpx, heightpx, mm2px, 
            $('#card_h').val() * mm2px,
            $('#fontsize').val() * mm2px,
            $('#padding').val() * mm2px);

          $(window).scrollTop(scroll);
        }

        function listWords() {
          var $words = $('#words'), $el, word;
          if (words) {
            cards = [];
            $words.empty();
            for(key in words) {
              word = (typeof words[key] === 'string') ? words[key] : (words[key].print || words[key].word);
              $el = $('<label></label>');
              $el.html('<span>' + key + ': ' + word + '</span><input data-key="' + key + '" type="number" value="1">');
              $el.appendTo($words);
              cards.push({
                id: key,
                display: word.trim(),
                n: 1,
                size: 1
              });

              $el.find('input').on('change keyup', function() {
                var $this = $(this),
                    id=$this.data('key'),
                    i;

                for (i = 0; i < cards.length; i++) {
                  if(cards[i].id == id) {
                    cards[i].n = parseInt($this.val());
                    break;
                  }
                }

                change();
              });
            }
          } else {
            $words.empty().text('No words available.');
          }
        }

        function draw(width, height, mm2px, cHeight, font, padding) {
          if (cHeight !== 0 && !isNaN(cHeight) &&
              font    !== 0 && !isNaN(font)    &&
              width   !== 0 && !isNaN(width)   &&
              height  !== 0 && !isNaN(height)  &&
              mm2px   !== 0 && !isNaN(mm2px)   &&
              !isNaN(padding)) {

            $('.svg:not(#template)').remove();

            var layers = {
                  guides: $('#guides_cb')[0].checked,
                  front: $('#front_cb')[0].checked,
                  back: $('#back_cb')[0].checked,
                  print: $('#print_cb')[0].checked,
                  cut: false
                },
                $template = $('#template'),
                $cont = $('#cont'),
                binsPerPage = Math.floor(height / cHeight),
                bins = [],
                $svgs, $svg, tmp, i, j, k, needNewBin, pages,
                soFar, bin, $guides;

            // Update all sizes:
            for (id in cards) {
              cards[id].size = getSize(cards[id].display);
            }

            // Sort cards
            cards.sort(function(a, b) {
              if (Math.round(a.size.w) !== Math.round(b.size.w)) {
                return b.size.w - a.size.w;
              } else if (a.display < b.display) {
                return 1;
              } else if (b.display < a.display) {
                return -1;
              } else {
                return 0;
              }
            });

            // Bin pack cards. 1st fit descending. Fuck yeah D1!
            for (i = 0; i < cards.length; i++) {
              for (j = 0; j < cards[i].n; j++) {
                if (cards[i].size.w > width) {
                  // Won't fit on a page.
                  console.log(cards[i].display + ' is too big');
                } else {
                  needNewBin = true;
                  for (k = 0; k < bins.length; k++) {
                    if (bins[k].remaining > cards[i].size.w) {
                      needNewBin = false;
                      bins[k].items.push(cards[i]);
                      bins[k].remaining -= cards[i].size.w;
                      break;
                    }
                  }

                  if(needNewBin) {
                    bins.push({
                      remaining: width,
                      items: []
                    });

                    // Force a loop of that same object
                    j--;
                  }
                }
              }
            }

            pages = Math.ceil(bins.length / binsPerPage);

            // Draw stuff.
            for(i = 0; i < pages; i++) {
              $svg = $template.clone()
                .appendTo($cont)
                .attr('id', 'page-' + i)
                .attr('download', 'page-' + i + '.svg')
                .find('svg');

              $guides = $svg.find('.guides');

              for (j = 0; j < binsPerPage; j++) {
                soFar = 0;
                if(bins[i * binsPerPage + j]) {
                  bin = bins[i * binsPerPage + j].items;
                  for(k = 0; k < bin.length; k++) {
                    if(layers.front) {

                      if(layers.print) {
                        text(bin[k],
                          centerx(soFar, soFar - bin[k].size.w, bin[k].size.width), 
                          centery(j * cHeight, (j + 1) * cHeight, bin[k].size.h/2), $svg);
                      }

                      soFar += bin[k].size.w;

                      if (layers.guides) {
                        c('line').attr({
                          x1: soFar,
                          x2: soFar,
                          y1: j * cHeight,
                          y2: (j + 1) * cHeight
                        }).appendTo($guides);
                      }
                    } else {
                      console.log('mew');
                      if(layers.print) {
                        console.log('yup');
                        text(bin[k],
                          centerx(soFar, soFar - bin[k].size.w, bin[k].size.width), 
                          centery(height - (j * cHeight), height - (j + 1) * cHeight, bin[k].size.h/2), $svg);
                      }

                      soFar += bin[k].size.w;

                      if (layers.guides) {
                        c('line').attr({
                          x1: soFar,
                          x2: soFar,
                          y1: height - j * cHeight,
                          y2: height - (j + 1) * cHeight
                        }).appendTo($guides);
                      }
                    }
                  }
                }
              }
            }

            $svgs = $('.svg:not(#template)');

            if(layers.guides) {
              $svgs.each(function(i, el) {
                svg = $(el).find('svg');
                drawGuides(svg);
              });
            }

            function drawGuides($el) {
              var i, line, rect, apt = $el.find('.guides');
              if(layers.front) {
                for (i = cHeight; i < height; i += cHeight) {
                  line = c('line');
                  line.attr({
                    x1: 0,
                    x2: width,
                    y1: i,
                    y2: i
                  });

                  line.appendTo(apt);
                }

                rect = c('rect');
                rect.attr({
                  x: 0,
                  y: i - cHeight,
                  width: width,
                  height: height - (i - cHeight),
                  fill: 'lime'
                });
                rect.appendTo(apt);
              } else {
                for (i = height - cHeight; i > 0; i -= cHeight) {
                  line = c('line');
                  line.attr({
                    x1: 0,
                    x2: width,
                    y1: i,
                    y2: i
                  });

                  line.appendTo(apt);
                }

                rect = c('rect');
                rect.attr({
                  x: 0,
                  y: 0,
                  width: width,
                  height: cHeight + i,
                  fill: 'lime'
                });
                rect.appendTo(apt);
              }
            }

            function getSize(text) {
              var $txt = c('text'),
                  bbox, obj;

              $txt.attr({
                x: 0,
                y: font,
                'font-size': font
              });

              $txt[0].textContent = text;

              $txt.appendTo($template.find('svg'));
              $template.css('display', 'block');
              bbox = $txt[0].getBBox();
              $template.css('display', '');
              $txt.remove();

              obj = {width: bbox.width + (padding * 2), h: bbox.height};
              obj.w = (obj.width < cHeight) ? cHeight : obj.width;

              return obj;
            }

            function text(obj, x, y, $svg) {
              var $el = c('text');

              $el[0].textContent = obj.display;

              $el.attr({
                x: x + padding,
                y: y,
                'font-size': font
              });

              $el.appendTo($svg);
            }

            function centery(min, max, mid) {
              return (min + (max - min) / 2) + (mid / 2);
            }
            function centerx(min, max, mid) {
              return (min + (min - max) / 2) - (mid / 2);
            }

            function c(name) {
              return $(document.createElementNS('http://www.w3.org/2000/svg', name));
            }
          }
        };

      });
    </script>

    <style>
      * {
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
      }

      body, html {
        width: 100%;
        height: 100%;
      }

      body {
        margin: 20px;
      }

      .hidden {
        display: none;
      }

      .options {
        position: fixed;
        width: 100%;
        top: 0;
        left: 0;
        padding: 20px;
        background-color: white;
        border-bottom: 1px solid black;
        z-index: 100;
      }

      h1 {
        margin-top: 90px;
      }

      #words {
        -webkit-columns: 200px;
        -moz-columns: 200px;
        -o-columns: 200px;
        columns: 200px;
      }

      #words label {
        display: block;
      }

      #words span {
        display: inline-block;
        width: 66%;
      }

      a {
        text-decoration: none;
      }

      .svg {
        display: inline-block;
        padding: 0;
        padding-bottom: 20px;
        margin: 20px;
        overflow: visible;
      }

      svg {
        box-shadow: 0 5px 25px rgba(0, 0, 0, 0.3);
      }

      svg:hover {
        box-shadow: 0 5px 25px rgba(0, 0, 0, 0.4);
      }

      input[type=number] {
        width: 50px;
        text-align: center;
      }

      #template {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="options">
      <label>Size: <input type="number" id="size_w" placeholder="Width" value="297">mm</label>
      <label>&times;<input type="number" id="size_h" placeholder="Height" value="210">mm.</label>
      <select id="size">
        <option value="297 210" selected>A4 (landscape)</option>
        <option value="210 297">A4 (portrait)</option>
        <option value="420 297">A3 (landscape)</option>
        <option value="297 420">A3 (portrait)</option>
        <option value="594 420">A2 (landscape)</option>
        <option value="420 594">A2 (portrait)</option>
        <option value="841 594">A1 (landscape)</option>
        <option value="594 841">A1 (portrait)</option>
        <option value="1189 841">A0 (landscape)</option>
        <option value="841 1189">A0 (portrait)</option>
      </select>
      <label>Resolution: <input type="number" id="dpi" value="300">dpi.</label>
      <label>Card Height: <input type="number" id="card_h" value="40">mm.</label>
      <label>Font Size: <input type="number" id="fontsize" value="20">mm.</label>
      <label>Padding: <input type="number" id="padding" value="8">mm.</label>
      <div>
        Layers: 
        <label><input type="radio" id="front_cb" name="fb" checked>Front</label>
        <label><input type="radio" id="back_cb" name="fb">Back</label>
        <label><input type="radio" id="print_cb" name="pc" checked>Print</label>
        <label><input type="radio" id="cut_cb" name="pc">Cut lines</label>
        <label><input type="checkbox" id="guides_cb" checked>Guides</label>
      </div>
    </div>
    <h1>CodeCards card layout</h1>
    <label>Card set: <input type="text" id="lang" value="robot"></label><span id="notice"></span>
    <p><a href="#" id="toggleWords">Show/Hide words</a></p>
    <div id="words" class="hidden"></div>
    <div id="cont">
      <a class="svg" href="#" id="template" download="sample.svg">
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewbox="0 0 100 100" width="100px" height="100px">
          <style type="text/css">
            #first {
              stroke: none;
            }

            text {
              font-family: 'Inconsolata';
              text-rendering: optimizeLegibility;
              fill: black;
            }

            rect, line, path {
              stroke: black;
              stroke-width: 1px;
              fill: none;
              shape-rendering: crispEdges;
              vector-effect: non-scaling-stroke;
            }

            .guides line {
              stroke: magenta;
            }

            .guides rect {
              stroke: none;
              fill: magenta;
              fill-opacity: 0.3;
            }
          </style>

          <rect x="0" y="0" width="100%" height="100%" id="first"/>

          <g class="guides"></g>
        </svg>
      </a>
    </div>
    :)
  </body>
</html>